/** 
    在本章中，我们介绍了 Vue.js 内建的三个组件，即 KeepAlive 组
    件、Teleport 组件和 Transition 组件。它们的共同特点是，与渲染器的
    结合非常紧密，因此需要框架提供底层的实现与支持。

    KeepAlive 组件的作用类似于 HTTP 中的持久链接。它可以避免组
    件实例不断地被销毁和重建。KeepAlive 的基本实现并不复杂。当被
    KeepAlive 的组件“卸载”时，渲染器并不会真的将其卸载掉，而是会将
    该组件搬运到一个隐藏容器中，从而使得组件可以维持当前状态。当
    被 KeepAlive 的组件“挂载”时，渲染器也不会真的挂载它，而是将它从
    隐藏容器搬运到原容器。

    我们还讨论了 KeepAlive 的其他能力，如匹配策略和缓存策略。
    include 和 exclude 这两个选项用来指定哪些组件需要被
    KeepAlive，哪些组件不需要被 KeepAlive。默认情况下，include 和
    exclude 会匹配组件的 name 选项。但是在具体实现中，我们可以扩
    展匹配能力。对于缓存策略，Vue.js 默认采用“最新一次访问”。为了让
    用户能自行实现缓存策略，我们还介绍了正在讨论中的提案。

    接着，我们讨论了 Teleport 组件所要解决的问题和它的实现原理。
    Teleport 组件可以跨越 DOM 层级完成渲染，这在很多场景下非常有
    用。在实现 Teleport 时，我们将 Teleport 组件的渲染逻辑从渲染器中分
    离出来，这么做有两点好处：

        可以避免渲染器逻辑代码“膨胀”；
        可以利用 Tree-Shaking 机制在最终的 bundle 中删除 Teleport 相关
        的代码，使得最终构建包的体积变小。

    Teleport 组件是一个特殊的组件。与普通组件相比，它的组件选项
    非常特殊，例如 __isTeleport 选型和 process 选项等。这是因为
    Teleport 本质上是渲染器逻辑的合理抽象，它完全可以作为渲染器的一
    部分而存在。

    最后，我们讨论了 Transition 组件的原理与实现。我们从原生
    DOM 过渡开始，讲解了如何使用 JavaScript 为 DOM 元素添加进场动
    效和离场动效。在此过程中，我们将实现动效的过程分为多个阶段，
    即 beforeEnter、enter、leave 等。Transition 组件的实现原理与
    为原生 DOM 添加过渡效果的原理类似，我们将过渡相关的钩子函数定
    义到虚拟节点的 vnode.transition 对象中。渲染器在执行挂载和
    卸载操作时，会优先检查该虚拟节点是否需要进行过渡，如果需要，
    则会在合适的时机执行 vnode.transition 对象中定义的过渡相关
    钩子函数。
*/