/**
    在本章中，我们首先介绍了 Proxy 与 Reflect。Vue.js 3 的响应
式数据是基于 Proxy 实现的，Proxy 可以为其他对象创建一个代理对
象。所谓代理，指的是对一个对象基本语义的代理。它允许我们拦截
并重新定义对一个对象的基本操作。在实现代理的过程中，我们遇到
了访问器属性的 this 指向问题，这需要使用 Reflect.* 方法并指定
正确的 receiver 来解决。

    然后我们详细讨论了 JavaScript 中对象的概念，以及 Proxy 的工
作原理。在 ECMAScript 规范中，JavaScript 中有两种对象，其中一种
叫作常规对象，另一种叫作异质对象。满足以下三点要求的对象就是
常规对象：
        1. 对于表 5-1 给出的内部方法，必须使用规范 10.1.x 节给出的定义实
        现；
        2. 对于内部方法 [[Call]]，必须使用规范 10.2.1 节给出的定义实
        现；
        3. 对于内部方法 [[Construct]]，必须使用规范 10.2.2 节给出的
        定义实现。

    而所有不符合这三点要求的对象都是异质对象。一个对象是函数
还是其他对象，是由部署在该对象上的内部方法和内部槽决定的。

    接着，我们讨论了关于对象 Object 的代理。代理对象的本质，
就是查阅规范并找到可拦截的基本操作的方法。有一些操作并不是基
本操作，而是复合操作，这需要我们查阅规范了解它们都依赖哪些基
本操作，从而通过基本操作的拦截方法间接地处理复合操作。我们还
详细分析了添加、修改、删除属性对 for...in 操作的影响，其中添
加和删除属性都会影响 for...in 循环的执行次数，所以当这些操作
发生时，需要触发与 ITERATE_KEY 相关联的副作用函数重新执行。
而修改属性值则不影响 for...in 循环的执行次数，因此无须处理。
我们还讨论了如何合理地触发副作用函数重新执行，包括对 NaN 的处
理，以及访问原型链上的属性导致的副作用函数重新执行两次的问
题。对于 NaN，我们主要注意的是 NaN === NaN 永远等于 false。
对于原型链属性问题，需要我们查阅规范定位问题的原因。由此可
见，想要基于 Proxy 实现一个相对完善的响应系统，免不了去了解
ECMAScript 规范。

    而后，我们讨论了深响应与浅响应，以及深只读与浅只读。这里
的深和浅指的是对象的层级，浅响应（或只读）代表仅代理一个对象
的第一层属性，即只有对象的第一层属性值是响应（或只读）的。深
响应（或只读）则恰恰相反，为了实现深响应（或只读），我们需要
在返回属性值之前，对值做一层包装，将其包装为响应式（或只读）
数据后再返回。

    之后，我们讨论了关于数组的代理。数组是一个异质对象，因为
数组对象部署的内部方法 [[DefineOwnProperty]] 不同于常规对
象。通过索引为数组设置新的元素，可能会隐式地改变数组 length
属性的值。对应地，修改数组 length 属性的值，也可能会间接影响
数组中的已有元素。所以在触发响应的时候需要额外注意。我们还讨
论了如何拦截 for...in 和 for...of 对数组的遍历操作。使用
for...in 循环遍历数组与遍历普通对象区别不大，唯一需要注意的
是，当追踪 for...in 操作时，应该使用数组的 length 作为追踪的
key。for...of 基于迭代协议工作，数组内建了
Symbol.iterator 方法。根据规范的 23.1.5.1 节可知，数组迭代器
执行时，会读取数组的 length 属性或数组的索引。因此，我们不需
要做其他额外的处理，就能够实现对 for...of 迭代的响应式支持。

    我们还讨论了数组的查找方法。如 includes、indexOf 以及
lastIndexOf 等。对于数组元素的查找，需要注意的一点是，用户既
可能使用代理对象进行查找，也可能使用原始对象进行查找。为了支
持这两种形式，我们需要重写数组的查找方法。原理很简单，当用户
使用这些方法查找元素时，我们可以先去代理对象中查找，如果找不
到，再去原始数组中查找。

    我们还介绍了会隐式修改数组长度的原型方法，即 push、pop、
shift、unshift 以及 splice 等方法。调用这些方法会间接地读取
和设置数组的 length 属性，因此，在不同的副作用函数内对同一个
数组执行上述方法，会导致多个副作用函数之间循环调用，最终导致
调用栈溢出。为了解决这个问题，我们使用一个标记变量
shouldTrack 来代表是否允许进行追踪，然后重写了上述这些方法，
目的是，当这些方法间接读取 length 属性值时，我们会先将
shouldTrack 的值设置为 false，即禁止追踪。这样就可以断开
length 属性与副作用函数之间的响应联系，从而避免循环调用导致的
调用栈溢出。

    最后，我们讨论了关于集合类型数据的响应式方案。集合类型指
Set、Map、WeakSet 以及 WeakMap。我们讨论了使用 Proxy 为集
合类型创建代理对象的一些注意事项。集合类型不同于普通对象，它
有特定的数据操作方法。当使用 Proxy 代理集合类型的数据时要格外
注意，例如，集合类型的 size 属性是一个访问器属性，当通过代理
对象访问 size 属性时，由于代理对象本身并没有部署 [[SetData]]
这样的内部槽，所以会发生错误。另外，通过代理对象执行集合类型
的操作方法时，要注意这些方法执行时的 this 指向，我们需要在
get 拦截函数内通过 .bind 函数为这些方法绑定正确的 this 值。我
们还讨论了集合类型响应式数据的实现。我们需要通过“重写”集合方
法的方式来实现自定义的能力，当 Set 集合的 add 方法执行时，需要
调用 trigger 函数触发响应。我们也讨论了关于“数据污染”的问题。
数据污染指的是不小心将响应式数据添加到原始数据中，它导致用户
可以通过原始数据执行响应式相关操作，这不是我们所期望的。为了
避免这类问题发生，我们通过响应式数据对象的 raw 属性来访问对应
的原始数据对象，后续操作使用原始数据对象就可以了。我们还讨论
了关于集合类型的遍历，即 forEach 方法。集合的 forEach 方法与
对象的 for...in 遍历类似，最大的不同体现在，当使用 for...in
遍历对象时，我们只关心对象的键是否变化，而不关心值；但使用
forEach 遍历集合时，我们既关心键的变化，也关心值的变化。
 */