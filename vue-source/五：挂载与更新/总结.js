/**
    在本章中，我们首先讨论了如何挂载子节点，以及节点的属性。
对于子节点，只需要递归地调用 patch 函数完成挂载即可。而节点的
属性比想象中的复杂，它涉及两个重要的概念：HTML Attributes 和
DOM Properties。为元素设置属性时，我们不能总是使用
setAttribute 函数，也不能总是通过元素的 DOM Properties 来设
置。至于如何正确地为元素设置属性，取决于被设置属性的特点。例
如，表单元素的 el.form 属性是只读的，因此只能使用
setAttribute 函数来设置。

    接着，我们讨论了特殊属性的处理。以 class 为例，Vue.js 对
class 属性做了增强，它允许我们为 class 指定不同类型的值。但在
把这些值设置给 DOM 元素之前，要对值进行正常化。我们还讨论了为
元素设置 class 的三种方式及其性能情况。其中，el.className
的性能最优，所以我们选择在 patchProps 函数中使用
el.className 来完成 class 属性的设置。除了 class 属性之外，
Vue.js 也对 style 属性做了增强，所以 style 属性也需要做类似的处
理。

    然后，我们讨论了卸载操作。一开始，我们直接使用 innerHTML
来清空容器元素，但是这样存在诸多问题。
        1. 容器的内容可能是由某个或多个组件渲染的，当卸载操作发生
    时，应该正确地调用这些组件的 beforeUnmount、unmounted
    等生命周期函数。
        2. 即使内容不是由组件渲染的，有的元素存在自定义指令，我们应
    该在卸载操作发生时正确地执行对应的指令钩子函数。
        3. 使用 innerHTML 清空容器元素内容的另一个缺陷是，它不会移
    除绑定在 DOM 元素上的事件处理函数。

    因此，我们不能直接使用 innerHTML 来完成卸载任务。为了解
决这些问题，我们封装了 unmount 函数。该函数是以一个 vnode 的
维度来完成卸载的，它会根据 vnode.el 属性取得该虚拟节点对应的
真实 DOM，然后调用原生 DOM API 完成 DOM 元素的卸载。这样做
还有两点额外的好处。

        1. 在 unmount 函数内，我们有机会调用绑定在 DOM 元素上的指令
    钩子函数，例如 beforeUnmount、unmounted 等。
        2. 当 unmount 函数执行时，我们有机会检测虚拟节点 vnode 的类
    型。如果该虚拟节点描述的是组件，则我们也有机会调用组件相
    关的生命周期函数。

    而后，我们讨论了 vnode 类型的区分。渲染器在执行更新时，需
要优先检查新旧 vnode 所描述的内容是否相同。只有当它们所描述的
内容相同时，才有打补丁的必要。另外，即使它们描述的内容相同，
我们也需要进一步检查它们的类型，即检查 vnode.type 属性值的类
型，据此判断它描述的具体内容是什么。如果类型是字符串，则它描
述的是普通标签元素，这时我们会调用 mountElement 和
patchElement 来完成挂载和打补丁；如果类型是对象，则它描述的
是组件，这时需要调用 mountComponent 和 patchComponent 来完
成挂载和打补丁。

    我们还讲解了事件的处理。首先介绍了如何在虚拟节点中描述事
件，我们把 vnode.props 对象中以字符串 on 开头的属性当作事件对
待。接着，我们讲解了如何绑定和更新事件。在更新事件的时候，为
了提升性能，我们伪造了 invoker 函数，并把真正的事件处理函数存
储在 invoker.value 属性中，当事件需要更新时，只更新
invoker.value 的值即可，这样可以避免一次
removeEventListener 函数的调用。

    我们还讲解了如何处理事件与更新时机的问题。解决方案是，利
用事件处理函数被绑定到 DOM 元素的时间与事件触发时间之间的差
异。我们需要屏蔽所有绑定时间晚于事件触发时间的事件处理函数
的执行。

    之后，我们讨论了子节点的更新。我们对虚拟节点中的
children 属性进行了规范化，规定 vnode.children 属性只能有
如下三种类型。
        1. 字符串类型：代表元素具有文本子节点。
        2. 数组类型：代表元素具有一组子节点。
        3. null：代表元素没有子节点。

    在更新时，新旧 vnode 的子节点都有可能是以上三种情况之一，
所以在执行更新时一共要考虑九种可能，即图 8-5 所展示的那样。但落
实到代码中，我们并不需要罗列所有情况。另外，当新旧 vnode 都具
有一组子节点时，我们采用了比较笨的方式来完成更新，即卸载所有
旧子节点，再挂载所有新子节点。更好的做法是，通过 Diff 算法比较
新旧两组子节点，试图最大程度复用 DOM 元素。我们会在后续章节中
详细讲解 Diff 算法的工作原理。

    我们还讨论了如何使用虚拟节点来描述文本节点和注释节点。我
们利用了 symbol 类型值的唯一性，为文本节点和注释节点分别创建
唯一标识，并将其作为 vnode.type 属性的值。

    最后，我们讨论了 Fragment 及其用途。渲染器渲染 Fragment
的方式类似于渲染普通标签，不同的是，Fragment 本身并不会渲染
任何 DOM 元素。所以，只需要渲染一个 Fragment 的所有子节点即
可。
 */