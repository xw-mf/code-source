/**
    在本章中，我们首先介绍了副作用函数和响应式数据的概念，以
及它们之间的关系。一个响应式数据最基本的实现依赖于对“读取”和
“设置”操作的拦截，从而在副作用函数与响应式数据之间建立联系。
当“读取”操作发生时，我们将当前执行的副作用函数存储到“桶”中；当
“设置”操作发生时，再将副作用函数从“桶”里取出并执行。这就是响应
系统的根本实现原理。

    接着，我们实现了一个相对完善的响应系统。使用 WeakMap 配合
Map 构建了新的“桶”结构，从而能够在响应式数据与副作用函数之间
建立更加精确的联系。同时，我们也介绍了 WeakMap 与 Map 这两个
数据结构之间的区别。WeakMap 是弱引用的，它不影响垃圾回收器的
工作。当用户代码对一个对象没有引用关系时，WeakMap 不会阻止垃
圾回收器回收该对象。

    我们还讨论了分支切换导致的冗余副作用的问题，这个问题会导
致副作用函数进行不必要的更新。为了解决这个问题，我们需要在每
次副作用函数重新执行之前，清除上一次建立的响应联系，而当副作
用函数重新执行后，会再次建立新的响应联系，新的响应联系中不存
在冗余副作用问题，从而解决了问题。但在此过程中，我们还遇到了
遍历 Set 数据结构导致无限循环的新问题，该问题产生的原因可以从
ECMA 规范中得知，即“在调用 forEach 遍历 Set 集合时，如果一个
值已经被访问过了，但这个值被删除并重新添加到集合，如果此时
forEach 遍历没有结束，那么这个值会重新被访问。”解决方案是建
立一个新的 Set 数据结构用来遍历。

    然后，我们讨论了关于嵌套的副作用函数的问题。在实际场景
中，嵌套的副作用函数发生在组件嵌套的场景中，即父子组件关系。
这时为了避免在响应式数据与副作用函数之间建立的响应联系发生错
乱，我们需要使用副作用函数栈来存储不同的副作用函数。当一个副
作用函数执行完毕后，将其从栈中弹出。当读取响应式数据的时候，
被读取的响应式数据只会与当前栈顶的副作用函数建立响应联系，从
而解决问题。而后，我们遇到了副作用函数无限递归地调用自身，导
致栈溢出的问题。该问题的根本原因在于，对响应式数据的读取和设
置操作发生在同一个副作用函数内。解决办法很简单，如果 trigger
触发执行的副作用函数与当前正在执行的副作用函数相同，则不触
发执行。

    随后，我们讨论了响应系统的可调度性。所谓可调度，指的是当
trigger 动作触发副作用函数重新执行时，有能力决定副作用函数执
行的时机、次数以及方式。为了实现调度能力，我们为 effect 函数
增加了第二个选项参数，可以通过 scheduler 选项指定调用器，这
样用户可以通过调度器自行完成任务的调度。我们还讲解了如何通过
调度器实现任务去重，即通过一个微任务队列对任务进行缓存，从而
实现去重。

    而后，我们讲解了计算属性，即 computed。计算属性实际上是
一个懒执行的副作用函数，我们通过 lazy 选项使得副作用函数可以
懒执行。被标记为懒执行的副作用函数可以通过手动方式让其执行。
利用这个特点，我们设计了计算属性，当读取计算属性的值时，只需
要手动执行副作用函数即可。当计算属性依赖的响应式数据发生变化
时，会通过 scheduler 将 dirty 标记设置为 true，代表“脏”。这
样，下次读取计算属性的值时，我们会重新计算真正的值。

    之后，我们讨论了 watch 的实现原理。它本质上利用了副作用函
数重新执行时的可调度性。一个 watch 本身会创建一个 effect，当
这个 effect 依赖的响应式数据发生变化时，会执行该 effect 的调
度器函数，即 scheduler。这里的 scheduler 可以理解为“回调”，
所以我们只需要在 scheduler 中执行用户通过 watch 函数注册的回
调函数即可。此外，我们还讲解了立即执行回调的 watch，通过添加
新的 immediate 选项来实现，还讨论了如何控制回调函数的执行时
机，通过 flush 选项来指定回调函数具体的执行时机，本质上是利用
了调用器和异步的微任务队列。

    最后，我们讨论了过期的副作用函数，它会导致竞态问题。为了
解决这个问题，Vue.js 为 watch 的回调函数设计了第三个参数，即
onInvalidate。它是一个函数，用来注册过期回调。每当 watch 的
回调函数执行之前，会优先执行用户通过 onInvalidate 注册的过期
回调。这样，用户就有机会在过期回调中将上一次的副作用标记为“过
期”，从而解决竞态问题。
 */