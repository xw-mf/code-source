/**
    在本章中，我们首先讨论了如何使用虚拟节点来描述组件。使用
虚拟节点的 vnode.type 属性来存储组件对象，渲染器根据虚拟节点
的该属性的类型来判断它是否是组件。如果是组件，则渲染器会使用
mountComponent 和 patchComponent 来完成组件的挂载和更新。

    接着，我们讨论了组件的自更新。我们知道，在组件挂载阶段，
会为组件创建一个用于渲染其内容的副作用函数。该副作用函数会与
组件自身的响应式数据建立响应联系。当组件自身的响应式数据发生
变化时，会触发渲染副作用函数重新执行，即重新渲染。但由于默认
情况下重新渲染是同步执行的，这导致无法对任务去重，因此我们在
创建渲染副作用函数时，指定了自定义的调用器。该调度器的作用
是，当组件自身的响应式数据发生变化时，将渲染副作用函数缓冲到
微任务队列中。有了缓冲队列，我们即可实现对渲染任务的去重，从
而避免无用的重新渲染所导致的额外性能开销。

    然后，我们介绍了组件实例。它本质上是一个对象，包含了组件
运行过程中的状态，例如组件是否挂载、组件自身的响应式数据，以
及组件所渲染的内容（即 subtree）等。有了组件实例后，在渲染副
作用函数内，我们就可以根据组件实例上的状态标识，来决定应该进
行全新的挂载，还是应该打补丁。

    而后，我们讨论了组件的 props 与组件的被动更新。副作用自更
新所引起的子组件更新叫作子组件的被动更新。我们还介绍了渲染上
下文（renderContext），它实际上是组件实例的代理对象。在渲染
函数内访问组件实例所暴露的数据都是通过该代理对象实现的。

    之后，我们讨论了 setup 函数。该函数是为了组合式 API 而生
的，所以我们要避免将其与 Vue.js 2 中的“传统”组件选项混合使用。
setup 函数的返回值可以是两种类型，如果返回函数，则将该函数作
为组件的渲染函数；如果返回数据对象，则将该对象暴露到渲染上下
文中。

    emit 函数包含在 setupContext 对象中，可以通过 emit 函数
发射组件的自定义事件。通过 v-on 指令为组件绑定的事件在经过编
译后，会以 onXxx 的形式存储到 props 对象中。当 emit 函数执行
时，会在 props 对象中寻找对应的事件处理函数并执行它。

    随后，我们讨论了组件的插槽。它借鉴了 Web Component 中
<slot> 标签的概念。插槽内容会被编译为插槽函数，插槽函数的返回
值就是向槽位填充的内容。<slot> 标签则会被编译为插槽函数的调
用，通过执行对应的插槽函数，得到外部向槽位填充的内容（即虚拟
DOM），最后将该内容渲染到槽位中。

    最后，我们讨论了 onMounted 等用于注册生命周期钩子函数的
方法的实现。通过 onMounted 注册的生命周期函数会被注册到当前
组件实例的 instance.mounted 数组中。为了维护当前正在初始化
的组件实例，我们定义了全局变量 currentInstance，以及用来设
置该变量的 setCurrentInstance 函数。
 */